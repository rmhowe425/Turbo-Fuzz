import logging
from os import path
from json import load
from pathlib import Path

CONFIG_PATH = 'artifacts/config.json'
logging.basicConfig(filename="fuzz-monitor.log",
                    level=logging.INFO,
                    format="%(asctime)s - %(levelname)s - %(message)s",
                    filemode='a',
                    )

def read_config() -> dict[str, str]:
    """
    Reads in artifacts/config.json.

    Returns
    -------
    Dictionary containing the data in config.json
    """
    if not path.exists(CONFIG_PATH):
        logging.error(f"[!] Cannot read configuration file. `{CONFIG_PATH}` not found.")
        raise FileNotFoundError("Config file does not exist.")

    try:
        with open(CONFIG_PATH, 'r', encoding='utf-8') as fil:
            return load(fil)
    except Exception as e:
        logging.error(f"[!] Cannot read configuration file. {str(e)}")
        raise RuntimeError(f"Error reading config file from disk. {str(e)}")


def read_fuzzer_stats(f_path: str) -> dict[str, str]:
    """
    Parses the `fuzzer_stats` file generated by AFL
    for a given fuzzer and converts the data into a dictionary.

    Parameters
    ----------
    f_path : str
        File path to `fuzzer_stats`.

    Returns
    -------
    Dictionary containing data from `fuzzer_stats`.
    """
    if not path.exists(f_path):
        logging.error(f"[!] Cannot read configuration file. `{f_path}` not found.")
        raise FileNotFoundError("Config file does not exist.")

    try:
        with open(f_path, 'r') as fil:
            contents = fil.readlines()
    except Exception as e:
        logging.error(f"[!] Error reading `{f_path}`. {str(e)}")
        raise RuntimeError(f"Error reading `{f_path}`. {str(e)}")

    records = [record.replace(' ', '').replace('\n', '')
               for record in contents
               if ':' in record
               ]

    return dict(
        record.split(':')
        for record in records
    )


def get_frontier_seed(f_path: str) -> str:
    """
    Retrieves the file path of the preferred
    frontier seed to be used for symbolic analysis.

    Parameters
    ----------
    f_path : str
        File path to the list of AFL++ seeds.

    Returns
    -------
    File path to the preferred frontier seed.
    """
    if not path.exists(f_path):
        logging.error(f"[!] Cannot determine frontier seed. `{f_path}` not found.")
        raise FileNotFoundError(f"Cannot determine frontier seed. `{f_path}` not found.")
    elif '/queue' not in f_path:
        logging.error(f"[!] `{f_path}` does not contain valid seeds.")
        raise FileNotFoundError(f"[!] `{f_path}` does not contain valid seeds.")

    queue_path = Path(f_path)
    queue_seeds = sorted(
        queue_path.glob(pattern="id:*"),
        key=lambda p: p.stat().st_mtime,
        reverse=True
    )

    if queue_seeds:
        return queue_seeds[0].as_posix()
    else:
        return ""


def read_frontier_seed(f_path: str) -> bytes:
    """
    Reads the contents of a frontier seed corpus file.

    Parameters
    ----------
    f_path : str
        Absolute file path to a frontier seed.

    Returns
    -------
    File contents of a frontier seed.
    """
    if not path.exists(f_path):
        logging.error(f"[!] Cannot read frontier seed. `{f_path}` not found.")
        raise FileNotFoundError(f"Cannot read frontier seed. `{f_path}` not found.")

    try:
        with open(f_path, 'rb') as fil:
            return fil.read()
    except Exception as e:
        logging.error(f"[!] Error reading frontier seed. {str(e)}")
        raise RuntimeError(f"Error reading frontier seed. {str(e)}")


def write_new_seeds(seeds: list[bytes]):
    """
    List of new seeds to be used by AFL++ to gain
    coverage in an application being fuzzed.

    Parameters
    ----------
    seeds : list[bytes]
        List of new seeds to be written to disk
        that will allow AFL++ to gain additional
        fuzzing coverage.
    """
    for idx, seed in enumerate(seeds):
        filename = f'queue1/new_seed{idx}'

        try:
            with open(filename, 'wb') as fil:
                fil.write(seed)
        except Exception as e:
            logging.error(f"[!] Error writing seed to disk. {str(e)}")
            raise RuntimeError(f"Error writing seed to disk. {str(e)}")